<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHN Field Collab – サーバ不要コラボ地図</title>

<!-- MapLibre -->
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- Mapbox GL Draw（描画UI） -->
<link href="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-gl-draw@1.4.3/dist/mapbox-gl-draw.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-gl-draw@1.4.3/dist/mapbox-gl-draw.js"></script>

<!-- Turf（距離/面積/円など） -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<!-- EXIF（GPS抽出） -->
<script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>

<!-- Yjs + y-webrtc（P2P同期）-->
<script src="https://cdn.jsdelivr.net/npm/yjs@13.6.18/dist/yjs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/y-webrtc@10.6.3/dist/y-webrtc.min.js"></script>

<!-- FlatGeobuf（FGB出力） -->
<script src="https://cdn.jsdelivr.net/npm/flatgeobuf@3.25.0/dist/flatgeobuf.min.js"></script>

<!-- JSZip（ZIP作成） -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
:root{--bg:#f8fafc;--line:#e5e7eb;--text:#0f172a;--muted:#64748b;--accent:#2563eb;--panel:#ffffff}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans CJK JP",sans-serif;color:var(--text)}
#topbar{display:flex;gap:.5rem;align-items:center;padding:.6rem .75rem;border-bottom:1px solid var(--line);background:var(--bg);position:relative;z-index:3;flex-wrap:wrap}
#brand{font-weight:700}
.btn{padding:.5rem .75rem;border:1px solid var(--line);border-radius:.6rem;background:#fff;cursor:pointer;font-size:.95rem}
.btn.active{border-color:var(--accent);box-shadow:0 0 0 2px rgba(37,99,235,.15) inset}
.btn:disabled{opacity:.5;cursor:not-allowed}
.badge{font-size:.82rem;padding:.2rem .55rem;border:1px solid var(--line);border-radius:999px;background:#fff}
.sep{width:1px;height:28px;background:var(--line);margin:0 .25rem}
.muted{color:var(--muted);font-size:.9rem}
#layout{position:relative;height:calc(100% - 64px)}
#map{position:absolute;inset:0 340px 0 0}
#side{position:absolute;right:0;top:0;bottom:0;width:340px;background:var(--panel);border-left:1px solid var(--line);display:flex;flex-direction:column}
#side .head{padding:.6rem .75rem;border-bottom:1px solid var(--line);display:flex;gap:.5rem;align-items:center;justify-content:space-between}
#list{overflow:auto;padding:.5rem}
.group{border:1px solid var(--line);border-radius:.6rem;margin-bottom:.5rem}
.group .ghead{display:flex;align-items:center;justify-content:space-between;padding:.45rem .6rem;background:#f9fafb;border-bottom:1px solid var(--line)}
.group .gitems{padding:.35rem;min-height:16px}
.item{display:flex;align-items:center;gap:.4rem;padding:.35rem;border-radius:.5rem}
.item:hover{background:#f3f4f6}
.item .name{flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.item .eye{cursor:pointer}
.item[draggable="true"]{cursor:grab}
.hidden{opacity:.5}
#err{display:none;position:fixed;left:12px;top:76px;background:#fee2e2;color:#7f1d1d;border:1px solid #fecaca;border-radius:.5rem;padding:.5rem .75rem;z-index:10}
#help{position:fixed;left:12px;bottom:12px;background:#fff;border:1px solid var(--line);border-radius:.75rem;padding:.6rem .75rem;font-size:.9rem;color:var(--muted);z-index:2}
.pin{width:26px;height:26px;transform:translateY(-2px)}
.photo-thumb{width:64px;height:64px;object-fit:cover;border-radius:.4rem;border:1px solid var(--line);box-shadow:0 1px 2px rgba(0,0,0,.06)}
#photo-input{display:none}
#modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:20}
#modal img{max-width:90vw;max-height:90vh;border-radius:.5rem;background:#000}
@media (max-width:1100px){#map{right:0}#side{position:static;width:100%;height:300px;border-left:none;border-top:1px solid var(--line)}#layout{height:calc(100% - 64px - 300px)}}
</style>
</head>
<body>
<div id="topbar">
  <span id="brand">PHN Field Collab</span>
  <span class="muted">短い room / editorKey をボタンで発行（短いURL）</span>
  <div class="sep"></div>

  <!-- Basemap -->
  <span class="muted">地図:</span>
  <button class="btn" id="bm-osm">OSM</button>
  <button class="btn" id="bm-gsi-std">地理院 標準</button>
  <button class="btn" id="bm-gsi-photo">地理院 写真</button>

  <div class="sep"></div>

  <!-- Tools -->
  <button class="btn" id="tool-select">選択</button>
  <button class="btn" id="tool-pin">ピン</button>
  <button class="btn" id="tool-line">ライン</button>
  <button class="btn" id="tool-poly">ポリゴン</button>
  <button class="btn" id="tool-circle">円</button>
  <button class="btn" id="tool-delete" title="選択削除 / 長押しで全削除">削除</button>
  <button class="btn" id="tool-photo">写真</button>
  <input type="file" id="photo-input" accept="image/*" multiple />

  <div class="sep"></div>

  <!-- Links / Export -->
  <button class="btn" id="btn-make-room">部屋を作成</button>
  <button class="btn" id="btn-make-editor">編集リンクを作成</button>
  <button class="btn" id="btn-copy-view">閲覧リンクをコピー</button>
  <button class="btn" id="btn-export">エクスポート</button>

  <div style="margin-left:auto;display:flex;gap:.5rem;align-items:center">
    <span class="badge" id="role-badge">閲覧専用</span>
    <span class="badge" id="room-pill">room: -</span>
  </div>
</div>

<div id="layout">
  <div id="map"></div>
  <aside id="side">
    <div class="head">
      <strong>レイヤ一覧</strong>
      <div style="display:flex;gap:.4rem">
        <button class="btn" id="btn-add-group">グループ追加</button>
        <button class="btn" id="btn-toggle-all">全表示/非表示</button>
      </div>
    </div>
    <div id="list"></div>
  </aside>
</div>

<div id="help">①「部屋を作成」で短いroom → ②OSM/地理院切替 → ③選択/ピン/ライン/ポリゴン/円/写真 → ④「編集リンク」「閲覧リンク」配布 → ⑤必要なら「エクスポート」。</div>
<div id="err"></div>

<!-- 画像拡大モーダル -->
<div id="modal" onclick="this.style.display='none'"><img id="modal-img" alt="photo"/></div>

<script>
(function(){
  // ========= ユーティリティ =========
  const $ = (id)=>document.getElementById(id);
  const showErr = (msg)=>{ const el=$('err'); el.textContent=msg; el.style.display='block'; console.error(msg); };
  const getHash = ()=> new URLSearchParams(location.hash.slice(1));
  const setHash = (q)=>{ location.hash=q.toString(); };
  const base62="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  function randomKey(len=12){ const a=new Uint8Array(len); crypto.getRandomValues(a); return Array.from(a, v=>base62[v%62]).join(''); }
  const nowId = ()=> 'id_'+Date.now().toString(36)+Math.random().toString(36).slice(2,7);
  const ts = ()=>{ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}${z(d.getMinutes())}${z(d.getSeconds())}`; };

  // ========= URL（短い r/k） =========
  const H = getHash();
  let ROOM_ID = H.get('r') || "";
  let EDITOR_KEY = H.get('k') || "";
  const READ_ONLY = !EDITOR_KEY;
  $('role-badge').textContent = READ_ONLY ? '閲覧専用' : '編集可';
  $('room-pill').textContent  = 'room: ' + (ROOM_ID || '-');

  function ensureRoom(q){ let r=q.get('r'); if(!r){ r=randomKey(12); q.set('r', r); } return r; }
  function buildViewURL(){ const q=getHash(); ensureRoom(q); q.delete('k'); q.delete('state'); return location.origin+location.pathname+'#'+q.toString(); }
  function buildEditorURL(){ const q=getHash(); ensureRoom(q); q.set('k', randomKey(16)); q.delete('state'); return location.origin+location.pathname+'#'+q.toString(); }

  // ========= Map =========
  const EMPTY_STYLE={version:8,sources:{},layers:[],glyphs:"https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf"};
  let map;
  try{ map=new maplibregl.Map({container:'map',style:EMPTY_STYLE,center:[135.79,34.51],zoom:8.2,bearing:0,pitch:0}); }
  catch(e){ showErr('Map初期化エラー: '+e.message); return; }

  // Basemap
  function addBasemap(){
    if(!map.getSource('osm')){
      map.addSource('osm',{type:'raster',tiles:['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],tileSize:256,
        attribution:'© OpenStreetMap contributors'});
    }
    if(!map.getSource('gsi-std')){
      map.addSource('gsi-std',{type:'raster',tiles:['https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png'],tileSize:256,
        attribution:'地理院 標準'});
    }
    if(!map.getSource('gsi-photo')){
      map.addSource('gsi-photo',{type:'raster',tiles:['https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg'],tileSize:256,
        attribution:'地理院 最新写真'});
    }
    if(!map.getLayer('bm-osm')) map.addLayer({id:'bm-osm',type:'raster',source:'osm'});
    if(!map.getLayer('bm-gsi-std')) map.addLayer({id:'bm-gsi-std',type:'raster',source:'gsi-std'});
    if(!map.getLayer('bm-gsi-photo')) map.addLayer({id:'bm-gsi-photo',type:'raster',source:'gsi-photo'});
  }
  function showBasemap(id){
    ['bm-osm','bm-gsi-std','bm-gsi-photo'].forEach(l=> map.getLayer(l) && map.setLayoutProperty(l,'visibility', l===id?'visible':'none'));
    ['bm-osm','bm-gsi-std','bm-gsi-photo'].forEach(btn=> $(btn).classList.toggle('active', btn===id));
  }
  map.on('load', ()=>{
    addBasemap(); showBasemap('bm-osm');
    // 現在地 → 失敗時は奈良県
    if (navigator.geolocation){
      navigator.geolocation.getCurrentPosition(
        pos=>map.jumpTo({center:[pos.coords.longitude,pos.coords.latitude],zoom:14}),
        _=>map.jumpTo({center:[135.79,34.51],zoom:8.2}),
        {enableHighAccuracy:true, timeout:7000, maximumAge:0}
      );
    } else { map.jumpTo({center:[135.79,34.51],zoom:8.2}); }
  });
  $('bm-osm').onclick = ()=>showBasemap('bm-osm');
  $('bm-gsi-std').onclick = ()=>showBasemap('bm-gsi-std');
  $('bm-gsi-photo').onclick = ()=>showBasemap('bm-gsi-photo');
  map.addControl(new maplibregl.NavigationControl({showZoom:true}), 'top-right');
  map.addControl(new maplibregl.GeolocateControl({positionOptions:{enableHighAccuracy:true},trackUserLocation:true,showUserHeading:true}));

  // ========= Draw（作図UI + 作成中破線化） =========
  const draw = new MapboxDraw({displayControlsDefault:false});
  map.addControl(draw,'top-left');

  function applyDashedPreview(){
    const targets=[
      ['gl-draw-line-stroke-active','line-dasharray',[2,2]],
      ['gl-draw-polygon-stroke-active','line-dasharray',[2,2]]
    ];
    targets.forEach(([id,prop,val])=>{
      if (map.getLayer(id)) try{ map.setPaintProperty(id, prop, val); }catch(_){}
    });
  }
  map.on('render', function once(){ applyDashedPreview(); map.off('render', once); });

  // ========= ラベル（数字/英字/記号OK、太字＆ハロ強め） =========
  function ensureLabelSource(){
    if (!map.getSource('labels')) map.addSource('labels', {type:'geojson', data:{type:'FeatureCollection',features:[]}});
    if (!map.getLayer('labels')){
      map.addLayer({
        id:'labels', type:'symbol', source:'labels',
        layout:{ 'text-field':['to-string',['get','label']], 'text-offset':[0,1.2], 'text-size':15, 'text-anchor':'top',
                 'text-font':['Noto Sans Regular','Open Sans Regular','Open Sans Bold'] },
        paint:{ 'text-color':'#111','text-halo-color':'#fff','text-halo-width':2.4,'text-halo-blur':0.4 }
      });
    }
  }

  // ========= Yjs 同期 / ローカル代替 =========
  const hasY = !!(window.Y && window.ywebrtc);
  const ydoc = hasY ? new Y.Doc() : null;
  const provider = hasY && ROOM_ID ? new ywebrtc.WebrtcProvider(ROOM_ID, ydoc) : null;
  const yFeatures = hasY ? ydoc.getArray('features') : null;   // すべての要素（Feature）
  const yGroups   = hasY ? ydoc.getArray('groupList') : null;  // [{id,name,order,visible}]
  const localFeatures = [];
  const localGroupList = [{id:'__ungroup',name:'未分類',order:0,visible:true}];

  function groupsArr(){ return hasY ? yGroups.toArray() : localGroupList; }
  function setGroups(arr){ if (hasY){ yGroups.delete(0,yGroups.length); arr.forEach(g=>yGroups.push([g])); } else { localGroupList.splice(0,localGroupList.length,...arr); } }
  if (hasY && yGroups.length===0){ yGroups.push([{id:'__ungroup',name:'未分類',order:0,visible:true}]); }

  // ========= レンダリング =========
  const markers = new Map(); // id -> Marker
  const photosFull = new Map(); // id -> dataURL(大)

  function clearMarkers(){ markers.forEach(m=>m.remove()); markers.clear(); }
  function featureToBbox(f){ try { return turf.bbox(f); } catch { return null; } }

  function addPinMarker(f){
    const el=document.createElement('div');
    el.innerHTML = `
      <svg class="pin" viewBox="0 0 24 24" fill="#d00" stroke="#fff" stroke-width="1.5">
        <path d="M12 22s-6-5.33-6-10a6 6 0 1 1 12 0c0 4.67-6 10-6 10z"></path>
        <circle cx="12" cy="10" r="2.8" fill="#fff"></circle>
      </svg>`;
    const marker = new maplibregl.Marker({element:el, anchor:'bottom'}).setLngLat(f.geometry.coordinates).addTo(map);
    markers.set(f.id, marker);
  }

  function addPhotoMarker(f){
    const el=document.createElement('div'); el.style.display='flex'; el.style.flexDirection='column'; el.style.alignItems='center';
    const img=document.createElement('img'); img.src=f.properties.thumb; img.className='photo-thumb'; img.alt=f.properties.label||'photo';
    el.appendChild(img);
    if (f.properties?.label){ const cap=document.createElement('div'); cap.textContent=f.properties.label; cap.style.fontSize='.8rem'; cap.style.marginTop='.2rem'; el.appendChild(cap); }
    img.onclick=()=>{ const full=photosFull.get(f.id) || f.properties.thumb; $('modal-img').src=full; $('modal').style.display='flex'; };
    const marker = new maplibregl.Marker({element:el, anchor:'bottom'}).setLngLat(f.geometry.coordinates).addTo(map);
    markers.set(f.id, marker);
  }

  function renderAll(){
    const feats = hasY ? yFeatures.toArray() : localFeatures;
    try{ draw.deleteAll(); }catch(_){}
    clearMarkers();
    const labelPts=[];
    for(const f of feats){
      if (f.properties?.visible===false) continue;
      if (f.properties?.kind==='pin'){ addPinMarker(f); if(f.properties?.label){ labelPts.push({type:'Feature',geometry:{type:'Point',coordinates:f.geometry.coordinates},properties:{label:f.properties.label}}); } }
      else if (f.properties?.kind==='photo'){ addPhotoMarker(f); if(f.properties?.label){ labelPts.push({type:'Feature',geometry:{type:'Point',coordinates:f.geometry.coordinates},properties:{label:f.properties.label}}); } }
      else { try{ draw.add(f); }catch(_){}
        if (f.properties?.label){
          let p; try{ p=f.geometry.type==='LineString'?turf.center(f).geometry:turf.centerOfMass(f).geometry; labelPts.push({type:'Feature',geometry:p,properties:{label:f.properties.label}});}catch(_){}
        }
      }
    }
    ensureLabelSource();
    map.getSource('labels')?.setData({type:'FeatureCollection',features:labelPts});
    rebuildSidebar();
  }

  // ========= 作図フロー =========
  let activeTool='select'; // 'select'|'pin'|'line'|'poly'|'circle'|'photo'
  let circleCenter=null;   // 1クリック目で中心
  let placingPhoto=null;   // {thumb, fullURL, label}

  function setTool(t){
    activeTool=t;
    ['tool-select','tool-pin','tool-line','tool-poly','tool-circle','tool-photo'].forEach(id=>$(id).classList.toggle('active', id==='tool-'+t));
    if (t==='line') draw.changeMode('draw_line_string');
    else if (t==='poly') draw.changeMode('draw_polygon');
    else draw.changeMode('simple_select'); // select/pin/circle/photo はここ
  }
  $('tool-select').onclick=()=> setTool('select');
  $('tool-pin').onclick = ()=> { if(!EDITOR_KEY){alert('閲覧専用です。編集リンクを作成してください。'); return;} setTool('pin'); };
  $('tool-line').onclick= ()=> { if(!EDITOR_KEY){alert('閲覧専用です。'); return;} setTool('line'); };
  $('tool-poly').onclick= ()=> { if(!EDITOR_KEY){alert('閲覧専用です。'); return;} setTool('poly'); };
  $('tool-circle').onclick=()=> { if(!EDITOR_KEY){alert('閲覧専用です。'); return;} setTool('circle'); circleCenter=null; };
  $('tool-photo').onclick =()=> { if(!EDITOR_KEY){alert('閲覧専用です。'); return;} $('photo-input').click(); };
  setTool('select');

  // 円：1クリック中心→マウス追従→2クリック確定（半径mを属性に保存）
  function updateCirclePreview(center, edge){
    const r = turf.distance(center, edge, {units:'kilometers'});
    const poly = turf.circle(center, r, {steps:64, units:'kilometers'});
    if (!map.getSource('circle-preview')){
      map.addSource('circle-preview',{type:'geojson',data:poly});
      map.addLayer({id:'circle-preview',type:'line',source:'circle-preview',paint:{'line-color':'#333','line-width':2,'line-dasharray':[2,2]}});
    } else { map.getSource('circle-preview').setData(poly); }
  }
  function clearCirclePreview(){ if (map.getLayer('circle-preview')) map.removeLayer('circle-preview'); if (map.getSource('circle-preview')) map.removeSource('circle-preview'); }
  map.on('mousemove', (e)=>{ if(activeTool==='circle' && circleCenter){ updateCirclePreview(circleCenter, [e.lngLat.lng,e.lngLat.lat]); } });
  map.on('click', (e)=>{
    if (activeTool==='pin'){
      const label = prompt('ピンのラベル（任意）') || '';
      const feat = {type:'Feature', id:nowId(), geometry:{type:'Point',coordinates:[e.lngLat.lng,e.lngLat.lat]}, properties:{kind:'pin', label, visible:true}};
      addFeature(feat); return;
    }
    if (activeTool==='circle'){
      if (!circleCenter){ circleCenter=[e.lngLat.lng,e.lngLat.lat]; updateCirclePreview(circleCenter,circleCenter); return; }
      const rkm=turf.distance(circleCenter,[e.lngLat.lng,e.lngLat.lat],{units:'kilometers'});
      const poly=turf.circle(circleCenter,rkm,{steps:64,units:'kilometers'});
      clearCirclePreview(); const label=prompt('円のラベル（任意）')||'';
      const feat={type:'Feature',id:nowId(),geometry:poly.geometry,properties:{kind:'circle',label,visible:true,radius_m:Math.round(rkm*1000)}};
      circleCenter=null; addFeature(feat); setTool('select'); return;
    }
    if (placingPhoto){
      const feat = {type:'Feature', id:nowId(), geometry:{type:'Point',coordinates:[e.lngLat.lng,e.lngLat.lat]}, properties:{kind:'photo', label:placingPhoto.label||'', thumb:placingPhoto.thumb, visible:true}};
      photosFull.set(feat.id, placingPhoto.fullURL); placingPhoto=null; addFeature(feat); alert('写真を配置しました。'); return;
    }
  });

  // ライン/ポリゴン：確定時にラベル入力
  map.on('draw.create', (e)=>{
    const f = e.features[0]; if(!f) return;
    if (f.geometry.type==='Point'){ draw.delete(f.id); return; }
    const label = prompt((f.geometry.type==='LineString'?'ライン':'ポリゴン')+'のラベル（任意）') || '';
    const kind = (f.geometry.type==='LineString'?'line':'polygon');
    const feat = {type:'Feature', id:nowId(), geometry:f.geometry, properties:{kind, label, visible:true}};
    draw.delete(f.id); addFeature(feat); setTool('select');
  });

  // 写真アップロード：EXIF座標を厳密に取得
  $('photo-input').addEventListener('change', async (ev)=>{
    const files=[...ev.target.files];
    for(const file of files){
      let lat=null, lon=null;
      try {
        const gps1 = await exifr.gps(file); // {latitude, longitude} or null
        if (gps1 && typeof gps1.latitude==='number' && typeof gps1.longitude==='number'){
          lat=gps1.latitude; lon=gps1.longitude;
        } else {
          const exif = await exifr.parse(file, {gps:true}).catch(()=>null);
          if (exif && exif.GPSLatitude && exif.GPSLongitude){
            const toDec = (arr, ref)=> (arr[0]+arr[1]/60+arr[2]/3600) * (ref==='S'||ref==='W'?-1:1);
            lat = toDec(exif.GPSLatitude, exif.GPSLatitudeRef||'N');
            lon = toDec(exif.GPSLongitude, exif.GPSLongitudeRef||'E');
          }
        }
      } catch(_) {}
      const img = await fileToImage(file);
      const {thumb,fullURL} = await makeThumb(img, 800, 512);
      const label = file.name.replace(/\.[^.]+$/,'');
      if (lat!=null && lon!=null){
        const feat = {type:'Feature', id:nowId(), geometry:{type:'Point',coordinates:[lon,lat]}, properties:{kind:'photo', label, thumb, visible:true}};
        photosFull.set(feat.id, fullURL); addFeature(feat);
      } else {
        placingPhoto = {thumb, fullURL, label};
        alert('この写真にはGPSがありません。地図をクリックして配置してください。');
      }
    }
    ev.target.value='';
  });
  function fileToImage(file){ return new Promise((res,rej)=>{ const url=URL.createObjectURL(file); const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=url; }); }
  async function makeThumb(img, fullMax=800, thumbMax=512){
    function resizeToDataURL(img, max){
      const scale=Math.min(1, max/Math.max(img.naturalWidth,img.naturalHeight));
      const w=Math.round(img.naturalWidth*scale), h=Math.round(img.naturalHeight*scale);
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const ctx=c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(img,0,0,w,h); return c.toDataURL('image/jpeg', 0.75);
    }
    const fullURL = resizeToDataURL(img, fullMax);
    const thumb   = resizeToDataURL(img, thumbMax);
    return {thumb, fullURL};
  }

  // ========= Features & Groups（保存/更新） =========
  function featsArr(){ return hasY ? yFeatures.toArray() : localFeatures; }
  function setFeats(newArr){ if (hasY){ yFeatures.delete(0,yFeatures.length); newArr.forEach(f=>yFeatures.push([f])); } else { localFeatures.splice(0,localFeatures.length,...newArr); } }
  function addFeature(feat){ if (hasY) yFeatures.push([feat]); else localFeatures.push(feat); renderAll(); }
  function updateFeature(id, updater){
    const feats = featsArr();
    const idx = feats.findIndex(f=>f.id===id); if (idx<0) return;
    const nf = JSON.parse(JSON.stringify(feats[idx])); updater(nf);
    feats[idx]=nf; setFeats(feats); renderAll();
  }
  function deleteFeature(id){
    const feats = featsArr(); const idx = feats.findIndex(f=>f.id===id); if (idx<0) return;
    feats.splice(idx,1); setFeats(feats); photosFull.delete(id); renderAll();
  }

  // ========= サイドバー（D&D 並び替え／グループ化） =========
  function ensureGroup(name){
    const gl = groupsArr();
    const found = gl.find(g=>g.name===name);
    if (found) return found.id;
    const id='g_'+randomKey(8);
    const maxOrder = Math.max(...gl.map(g=>g.order||0),0);
    const ng={id,name,order:maxOrder+1,visible:true};
    const arr=[...gl, ng]; setGroups(arr);
    return id;
  }
  function groupNameById(id){
    const g = groupsArr().find(x=>x.id===id);
    return g ? g.name : '未分類';
  }
  function rebuildSidebar(){
    const feats = featsArr().slice().sort((a,b)=>(a.properties?.order||0)-(b.properties?.order||0));
    const gl = groupsArr().slice().sort((a,b)=>(a.order||0)-(b.order||0));
    // 未分類が無い場合は付与
    if (!gl.find(g=>g.id==='__ungroup')) setGroups([{id:'__ungroup',name:'未分類',order:0,visible:true}, ...gl]);
    const byGroup = new Map(gl.map(g=>[g.id, []]));
    feats.forEach(f=>{ const gid=f.properties?.groupId||'__ungroup'; (byGroup.get(gid)||byGroup.get('__ungroup')).push(f); });

    const list=$('list'); list.innerHTML='';
    gl.forEach(g=>{
      const box=document.createElement('div'); box.className='group'; box.dataset.gid=g.id;

      const head=document.createElement('div'); head.className='ghead'; head.dataset.gid=g.id;
      const title=document.createElement('div'); title.textContent=g.name; head.appendChild(title);
      const geye=document.createElement('span'); geye.textContent='👁'; geye.style.cursor='pointer';
      head.appendChild(geye); box.appendChild(head);

      geye.onclick=()=>{
        const arr = (byGroup.get(g.id)||[]);
        const currentVisible = arr.some(f=>f.properties?.visible!==false);
        arr.forEach(f=>updateFeature(f.id, nf=>{ nf.properties.visible = !currentVisible; }));
      };

      // グループへアイテムをドロップして移動
      head.addEventListener('dragover', e=>{ e.preventDefault(); });
      head.addEventListener('drop', e=>{
        e.preventDefault();
        const fromId=e.dataTransfer.getData('text/plain'); if(!fromId) return;
        updateFeature(fromId, nf=>{ nf.properties.groupId = g.id; });
      });

      const items=document.createElement('div'); items.className='gitems'; items.dataset.gid=g.id;

      (byGroup.get(g.id)||[]).forEach(f=>{
        const it=document.createElement('div'); it.className='item'; it.setAttribute('draggable','true'); it.dataset.id=f.id; it.dataset.gid=g.id;
        if (f.properties?.visible===false) it.classList.add('hidden');

        const eye=document.createElement('span'); eye.textContent=(f.properties?.visible===false)?'🙈':'👁'; eye.className='eye';
        eye.onclick=()=> updateFeature(f.id, nf=>{ const cur = nf.properties?.visible !== false; nf.properties.visible = !cur; });

        const name=document.createElement('div'); name.className='name';
        name.textContent=`${kindLabel(f.properties?.kind)}：${f.properties?.label||'(無題)'}`;
        name.onclick=()=>{
          if (f.geometry.type==='Point'){ map.flyTo({center:f.geometry.coordinates, zoom:18}); }
          else { const b=featureToBbox(f); if(b) map.fitBounds([[b[0],b[1]],[b[2],b[3]]],{padding:40}); }
        };

        const edit=document.createElement('button'); edit.textContent='✏️'; edit.className='btn';
        edit.onclick=()=>{
          const lab=prompt('ラベルを編集', f.properties?.label||'')||'';
          updateFeature(f.id, nf=>{ nf.properties.label=lab; });
        };

        const del=document.createElement('button'); del.textContent='🗑'; del.className='btn';
        del.onclick=()=>{ if(confirm('削除しますか？')) deleteFeature(f.id); };

        it.appendChild(eye); it.appendChild(name); it.appendChild(edit); it.appendChild(del);
        items.appendChild(it);
      });

      // D&D 並び替え／重ねて新規グループ化
      let dragId=null;
      items.addEventListener('dragstart', e=>{ const it=e.target.closest('.item'); if(!it) return; dragId=it.dataset.id; e.dataTransfer.setData('text/plain', dragId); });
      items.addEventListener('dragover', e=>{ e.preventDefault(); });
      items.addEventListener('drop', e=>{
        e.preventDefault();
        const fromId=e.dataTransfer.getData('text/plain'); if(!fromId) return;
        const toItem=e.target.closest('.item');

        if (toItem){
          const toId=toItem.dataset.id;
          const feats = featsArr();
          const fromF = feats.find(f=>f.id===fromId);
          const toF   = feats.find(f=>f.id===toId);
          if (!fromF || !toF) return;

          const fromG = fromF.properties?.groupId || '__ungroup';
          const toG   = toF.properties?.groupId   || '__ungroup';

          if (fromG === toG){
            const newName = prompt('新しいグループ名を入力','新規グループ');
            if (!newName) return;
            const newGid = ensureGroup(newName);
            fromF.properties = {...fromF.properties, groupId:newGid};
            toF.properties   = {...toF.properties,   groupId:newGid};
            setFeats(feats); renderAll();
          } else {
            // 異なるグループ → そのグループへ移動
            updateFeature(fromId, nf=>{ nf.properties.groupId = toG; });
          }
        } else {
          // 同じグループ内の空白に落ちた → 並び順のみ（DOM順は次の normalizeOrder で）
          normalizeOrder();
        }
      });

      // グループ自体へのドロップ（ヘッダ以外のスペース）
      items.addEventListener('dragover', e=>{ e.preventDefault(); });
      items.addEventListener('drop', e=>{
        const fromId=e.dataTransfer.getData('text/plain'); if(!fromId) return;
        updateFeature(fromId, nf=>{ nf.properties.groupId = g.id; });
      });

      box.appendChild(items);
      list.appendChild(box);
    });
  }

  function normalizeOrder(){
    const feats = featsArr();
    const list = $('list');
    let order = 0;
    list.querySelectorAll('.group .gitems .item').forEach(it=>{
      const id = it.dataset.id;
      const f = feats.find(x=>x.id===id);
      if (f){ f.properties = {...f.properties, order: order++ }; }
    });
    setFeats(feats);
  }

  function kindLabel(k){ return k==='pin'?'ピン':k==='photo'?'写真':k==='line'?'ライン':k==='polygon'?'ポリゴン':k==='circle'?'円':'項目'; }

  $('btn-add-group').onclick=()=>{
    const name = prompt('新しいグループ名','新しいグループ'); if(!name) return;
    ensureGroup(name); rebuildSidebar();
  };

  $('btn-toggle-all').onclick=()=>{
    const feats = featsArr();
    const anyVisible = feats.some(f=>f.properties?.visible!==false);
    feats.forEach(f=> f.properties = {...f.properties, visible: !anyVisible});
    setFeats(feats); renderAll();
  };

  // ========= 削除 =========
  $('tool-delete').onclick=()=>{
    if(!EDITOR_KEY){ alert('閲覧専用です。'); return; }
    const ids = draw.getSelectedIds ? draw.getSelectedIds() : [];
    if (ids.length) { draw.trash(); return; }
    alert('削除はサイドバーの🗑から行ってください。');
  };

  // ========= リンク作成（短いURL） =========
  $('btn-make-room').onclick=()=>{
    const q=getHash(); const r=ensureRoom(q); q.delete('k'); q.delete('state'); setHash(q);
    ROOM_ID=r; $('room-pill').textContent='room: '+ROOM_ID;
    alert('部屋を作成しました。URLを共有してください。');
    if (hasY && !provider){ new ywebrtc.WebrtcProvider(ROOM_ID, ydoc); }
  };
  $('btn-make-editor').onclick=async ()=>{
    const url=buildEditorURL();
    try{ await navigator.clipboard.writeText(url); }catch(e){}
    location.hash = url.split('#')[1];
    const q=getHash(); ROOM_ID=q.get('r')||ROOM_ID; EDITOR_KEY=q.get('k')||EDITOR_KEY;
    $('role-badge').textContent=EDITOR_KEY?'編集可':'閲覧専用';
    $('room-pill').textContent='room: '+ROOM_ID;
    alert('編集リンクをコピーしました。\n'+url);
  };
  $('btn-copy-view').onclick=async ()=>{
    const url=buildViewURL();
    try{ await navigator.clipboard.writeText(url); alert('閲覧リンクをコピーしました。\n'+url); }
    catch(e){ prompt('コピーできない場合は手動でコピーしてください', url); }
  };

  // ========= エクスポート（FGB & CSV → ZIP） =========
  $('btn-export').onclick = async ()=>{
    try{
      const feats = featsArr();
      // 種別ごとに抽出
      const points = feats.filter(f=>f.properties?.kind==='pin' || f.properties?.kind==='photo').map(clone);
      const lines  = feats.filter(f=>f.properties?.kind==='line').map(clone);
      const polys  = feats.filter(f=>f.properties?.kind==='polygon').map(clone);
      const circs  = feats.filter(f=>f.properties?.kind==='circle').map(clone);

      // 付加属性
      lines.forEach(f=>{ try{ f.properties.length_m = Math.round(turf.length(f,{units:'kilometers'})*1000); }catch{} });
      polys.forEach(f=>{ try{ f.properties.area_m2 = Math.round(turf.area(f)); }catch{} });
      // circle は半径_mを既に持つ
      // pin: CSV用に lon/lat 列を
      const pinRows = points.map(f=>({label: safe(f.properties?.label), lon: f.geometry.coordinates[0], lat: f.geometry.coordinates[1]}));
      const csv = toCSV(pinRows);

      // FGB 生成（flatgeobuf.serialize を使用）
      const fgbPoints = toFGB(points);
      const fgbLines  = toFGB(lines);
      const fgbPolys  = toFGB(polys);
      const fgbCircs  = toFGB(circs);

      const nameBase = ts();
      const zip = new JSZip();
      if (fgbPoints) zip.file(`${nameBase}_points.fgb`, new Blob([fgbPoints]));
      if (fgbLines)  zip.file(`${nameBase}_lines.fgb`,  new Blob([fgbLines]));
      if (fgbPolys)  zip.file(`${nameBase}_polygons.fgb`, new Blob([fgbPolys]));
      if (fgbCircs)  zip.file(`${nameBase}_circles.fgb`, new Blob([fgbCircs]));
      zip.file(`${nameBase}_points.csv`, new Blob([csv], {type:'text/csv'}));

      const blob = await zip.generateAsync({type:'blob'});

      // 保存ダイアログ
      if (window.showSaveFilePicker){
        const handle = await showSaveFilePicker({
          suggestedName: `${nameBase}_export.zip`,
          types:[{description:'ZIP', accept:{'application/zip':['.zip']}}]
        });
        const w = await handle.createWritable();
        await w.write(blob); await w.close();
        alert('エクスポート完了：'+handle.name);
      } else {
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download=`${nameBase}_export.zip`; a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 3000);
      }
    }catch(e){
      alert('エクスポートでエラー：'+e.message);
    }
  };

  function clone(f){ return JSON.parse(JSON.stringify(f)); }
  function safe(s){ return (s==null?'':String(s)); }
  function toCSV(rows){
    if (!rows.length) return 'label,lon,lat\n';
    const keys = Object.keys(rows[0]);
    const esc = v => `"${String(v).replace(/"/g,'""')}"`;
    const lines = [keys.join(',')].concat(rows.map(r=>keys.map(k=>esc(r[k]??'')).join(',')));
    return lines.join('\n')+'\n';
  }
  function toFGB(features){
    if (!features || features.length===0) return null;
    if (!window.flatgeobuf || !flatgeobuf.GeoJSON || !flatgeobuf.GeoJSON.serialize){
      throw new Error('FlatGeobufライブラリが読み込めませんでした');
    }
    const fc = {type:'FeatureCollection', features};
    return flatgeobuf.GeoJSON.serialize(fc); // Uint8Array
  }

  // ====== 監視して再描画（Yjs使用時）======
  if (hasY){ yFeatures.observeDeep(()=> renderAll()); if (yGroups) yGroups.observe(()=> rebuildSidebar()); }

  // 初期描画
  renderAll();
})();
</script>
</body>
</html>
